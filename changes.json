{
    "added_lines": [
        "++ b/pango/glyphstring.c",
        "{",
        "string->space = 4;",
        "}",
        "const guint max_space =",
        "MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));",
        "guint more_space = (guint)string->space * 2;",
        "if (more_space > max_space)",
        "{",
        "more_space = max_space;",
        "if ((guint)new_len > max_space)",
        "{",
        "g_error (\"%s: failed to allocate glyph string of length %i\\n\",",
        "G_STRLOC, new_len);",
        "}",
        "}",
        "string->space = more_space;"
    ],
    "removed_lines": [
        "string->space = 1;",
        "string->space *= 2;",
        "if (string->space < 0)",
        "g_warning (\"glyph string length overflows maximum integer size, truncated\");",
        "new_len = string->space = G_MAXINT - 8;"
    ]
}{
    "added_lines": [
        "++ b/examples/config/config",
        "@bind  <Button2>  = sh 'if [ \"$8\" ]; then uzbl-browser -u \"$8\"; else echo \"uri $(xclip -o | sed s/\\\\\\@/%40/g)\" > $4; fi' \\@SELECTED_URI"
    ],
    "removed_lines": [
        "@bind  <Button2>  = sh 'if [ \"\\@SELECTED_URI\" ]; then uzbl-browser -u \"\\@SELECTED_URI\"; else echo \"uri $(xclip -o | sed s/\\\\\\@/%40/g)\" > $4; fi'"
    ]
}{
    "added_lines": [
        "++ b/check-one.sh",
        "start_beanstalkd '' '-z 10'",
        "++ b/prot.c",
        "return skip(c, body_size + 2, MSG_JOB_TOO_BIG);",
        "++ b/sh-tests/too-big.commands",
        "put 0 0 0 11",
        "delete 9999",
        "quit",
        "++ b/sh-tests/too-big.expected",
        "JOB_TOO_BIG"
    ],
    "removed_lines": [
        "start_beanstalkd",
        "return reply_msg(c, MSG_JOB_TOO_BIG);"
    ]
}{
    "added_lines": [
        "++ b/src/core/network-openssl.c",
        "#include <openssl/x509v3.h>",
        "const char *hostname;",
        "static gboolean has_internal_nul(const char* str, int len) {",
        "while (len > 0 && str[len-1] == 0)",
        "len--;",
        "return strlen(str) != len;",
        "}",
        "static const char *tls_dns_name(const GENERAL_NAME * gn)",
        "{",
        "const char *dnsname;",
        "ASN1_IA5STRING values. Check we got the right union member. */",
        "if (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {",
        "g_warning(\"Invalid ASN1 value type in subjectAltName\");",
        "return NULL;",
        "}",
        "dnsname = (char *) ASN1_STRING_data(gn->d.ia5);",
        "if (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {",
        "g_warning(\"Internal NUL in subjectAltName\");",
        "return NULL;",
        "}",
        "return dnsname;",
        "}",
        "static char *tls_text_name(X509_NAME *name, int nid)",
        "{",
        "int     pos;",
        "X509_NAME_ENTRY *entry;",
        "ASN1_STRING *entry_str;",
        "int     utf8_length;",
        "unsigned char *utf8_value;",
        "char *result;",
        "if (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {",
        "return NULL;",
        "}",
        "entry = X509_NAME_get_entry(name, pos);",
        "g_return_val_if_fail(entry != NULL, NULL);",
        "entry_str = X509_NAME_ENTRY_get_data(entry);",
        "g_return_val_if_fail(entry_str != NULL, NULL);",
        "reasonable when converting ASCII formats that contain non-ASCII",
        "content. */",
        "if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {",
        "g_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));",
        "return NULL;",
        "}",
        "if (has_internal_nul((char *)utf8_value, utf8_length)) {",
        "g_warning(\"NUL character in hostname in certificate\");",
        "OPENSSL_free(utf8_value);",
        "return NULL;",
        "}",
        "result = g_strdup((char *) utf8_value);",
        "OPENSSL_free(utf8_value);",
        "return result;",
        "}",
        "static gboolean match_hostname(const char *cert_hostname, const char *hostname)",
        "{",
        "const char *hostname_left;",
        "if (!strcasecmp(cert_hostname, hostname)) {",
        "return TRUE;",
        "} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) {",
        "hostname_left = strchr(hostname, '.');",
        "if (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {",
        "return TRUE;",
        "}",
        "}",
        "return FALSE;",
        "}",
        "static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)",
        "{",
        "int gen_index, gen_count;",
        "gboolean matched = FALSE, has_dns_name = FALSE;",
        "const char *cert_dns_name;",
        "char *cert_subject_cn;",
        "const GENERAL_NAME *gn;",
        "STACK_OF(GENERAL_NAME) * gens;",
        "gens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);",
        "if (gens) {",
        "gen_count = sk_GENERAL_NAME_num(gens);",
        "for (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {",
        "gn = sk_GENERAL_NAME_value(gens, gen_index);",
        "if (gn->type != GEN_DNS)",
        "continue;",
        "ignore the CommonName, because subjectAltName:DNS is",
        "present (though malformed). */",
        "has_dns_name = TRUE;",
        "cert_dns_name = tls_dns_name(gn);",
        "if (cert_dns_name && *cert_dns_name) {",
        "matched = match_hostname(cert_dns_name, hostname);",
        "}",
        "}",
        "sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);",
        "}",
        "if (has_dns_name) {",
        "if (! matched) {",
        "g_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);",
        "}",
        "return matched;",
        "} else {",
        "cert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);",
        "if (cert_subject_cn && *cert_subject_cn) {",
        "matched = match_hostname(cert_subject_cn, hostname);",
        "if (! matched) {",
        "g_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);",
        "}",
        "} else {",
        "g_warning(\"No subjectAltNames and no valid common name in certificate\");",
        "}",
        "free(cert_subject_cn);",
        "}",
        "return matched;",
        "}",
        "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, const char* hostname, X509 *cert)",
        "} else if (! irssi_ssl_verify_hostname(cert, hostname)){",
        "return FALSE;",
        "static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *hostname, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)",
        "chan->hostname = hostname;",
        "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)",
        "ssl_handle  = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);",
        "ret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, chan->hostname, cert);",
        "++ b/src/core/network.h",
        "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify);",
        "++ b/src/core/servers.c",
        "net_connect_ip_ssl(ip, port, server->connrec->address, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,"
    ],
    "removed_lines": [
        "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)",
        "static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)",
        "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)",
        "ssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);",
        "ret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);"